<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matter.js Ball Pool</title>
    <script src="https://unpkg.com/matter-js@0.20.0/build/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        .debug-control {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .debug-control label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        canvas {
            display: block;
            /* Important for removing extra space below canvas */
            border: 2px solid #111;
            /* Added border */
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            /* Added shadow */
            border-radius: 8px;
            /* Added border radius */
            width: 100vw;
            /* Make canvas width 100% of viewport width */
            height: 100vh;
            /* Make canvas height 100% of viewport height */
        }
    </style>
    <script>
        var Example = Example || {};

        Example.ballPool = function () {
            var Engine = Matter.Engine,
                Render = Matter.Render,
                Runner = Matter.Runner,
                Composite = Matter.Composite,
                Composites = Matter.Composites,
                Common = Matter.Common,
                MouseConstraint = Matter.MouseConstraint,
                Mouse = Matter.Mouse,
                Bodies = Matter.Bodies,
                Vector = Matter.Vector, // Add Vector
                Query = Matter.Query;    // Add Query

            // criar motor
            var engine = Engine.create(),
                world = engine.world;

            // criar renderizador
            var render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    showAngleIndicator: false,
                    background: '#F0F0F0',
                    wireframes: false
                }
            });

            // Add debug mode checkbox
            const debugControl = document.createElement('div');
            debugControl.className = 'debug-control';
            debugControl.innerHTML = `
                <label>
                    <input type="checkbox" id="debugMode">
                    Debug Mode
                </label>
            `;
            document.body.appendChild(debugControl);

            // Load debug mode state from localStorage
            const debugCheckbox = document.getElementById('debugMode');
            debugCheckbox.checked = localStorage.getItem('debugMode') === 'true';

            // Update render options based on debug mode
            function updateDebugMode() {
                render.options.showAngleIndicator = debugCheckbox.checked;
                render.options.wireframes = debugCheckbox.checked;
                localStorage.setItem('debugMode', debugCheckbox.checked);

                // Store handler functions
                const handlers = {
                    mousedown: function (event) {
                        const button = event.button === 0 ? 'Left' : event.button === 1 ? 'Middle' : 'Right';
                        console.log(`${button} Mouse Down:`, {
                            x: event.clientX,
                            y: event.clientY,
                            button: button
                        });
                    },
                    mouseup: function (event) {
                        const button = event.button === 0 ? 'Left' : event.button === 1 ? 'Middle' : 'Right';
                        console.log(`${button} Mouse Up:`, {
                            x: event.clientX,
                            y: event.clientY,
                            button: button
                        });
                    },
                    click: function (event) {
                        const button = event.button === 0 ? 'Left' : event.button === 1 ? 'Middle' : 'Right';
                        console.log(`${button} Click - Object Created:`, {
                            x: event.clientX,
                            y: event.clientY,
                            button: button
                        });
                    },
                    contextmenu: function (event) {
                        console.log('Right Click - Object Removed:', {
                            x: event.clientX,
                            y: event.clientY,
                            button: 'Right'
                        });
                    },
                    mousemove: function (event) {
                        if (event.buttons > 0) {
                            const button = event.buttons === 1 ? 'Left' : event.buttons === 4 ? 'Middle' : 'Right';
                            console.log(`${button} Mouse Move (while pressed):`, {
                                x: event.clientX,
                                y: event.clientY,
                                button: button
                            });

                            if (button === 'Right') {
                                var bodies = Query.point(world.bodies, {
                                    x: event.clientX,
                                    y: event.clientY
                                });
                                if (bodies.length > 0 && !bodies[0].isStatic) {
                                    Composite.remove(world, bodies[0])
                                }
                            }

                            // while holding left button + control key, create a random body every 100ms
                            if (button === 'Left' && event.ctrlKey) {
                                // Throttle object creation to every 100ms
                                const currentTime = Date.now();
                                if (!window.lastCreationTime || currentTime - window.lastCreationTime >= 100) {
                                    var randomBody = createRandomBody(event.clientX, event.clientY);
                                    Composite.add(world, randomBody);
                                    window.lastCreationTime = currentTime;
                                }
                            }
                        }
                    }
                };

                // Toggle event logging based on debug mode
                render.canvas.addEventListener('mousedown', handlers.mousedown);
                render.canvas.addEventListener('mouseup', handlers.mouseup);
                render.canvas.addEventListener('click', handlers.click);
                render.canvas.addEventListener('contextmenu', handlers.contextmenu);
                render.canvas.addEventListener('mousemove', handlers.mousemove);
            }

            // Initial update
            updateDebugMode();

            // Add event listener for checkbox changes
            debugCheckbox.addEventListener('change', updateDebugMode);

            Render.run(render);

            // criar corredor
            var runner = Runner.create();
            Runner.run(runner, engine);

            // Adicionar limites - esquerda, direita, inferior
            Composite.add(world, [
                Bodies.rectangle(window.innerWidth / 2, window.innerHeight, window.innerWidth, 50.5, { // Inferior
                    isStatic: true,
                    render: {
                        fillStyle: '#060a19',
                        strokeStyle: '#000',
                        lineWidth: 2
                    }
                }),
                Bodies.rectangle(0, window.innerHeight / 2, 50.5, window.innerHeight, { // Esquerda
                    isStatic: true,
                    render: {
                        fillStyle: '#060a19',
                        strokeStyle: '#000',
                        lineWidth: 2
                    }
                }),
                Bodies.rectangle(window.innerWidth, window.innerHeight / 2, 50.5, window.innerHeight, { // Direita
                    isStatic: true,
                    render: {
                        fillStyle: '#060a19',
                        strokeStyle: '#000',
                        lineWidth: 2
                    }
                })
            ]);

            Composite.add(world, [
                Bodies.polygon(200, 460, 3, 60, {
                    restitution: 0.9, // Aumentei a restituição
                    friction: 0.1,
                    render: { fillStyle: '#4CAF50', strokeStyle: '#388E3C', lineWidth: 2 }
                }),
                Bodies.polygon(400, 460, 5, 60, {
                    restitution: 0.9, // Aumentei a restituição
                    friction: 0.1,
                    render: { fillStyle: '#2196F3', strokeStyle: '#1976D2', lineWidth: 2 }
                }),
                Bodies.rectangle(600, 460, 80, 80, {
                    restitution: 0.9, // Aumentei a restituição
                    friction: 0.1,
                    render: { fillStyle: '#FFC107', strokeStyle: '#FF8F00', lineWidth: 2 }
                })
            ]);

            // adicionar controlo do rato
            var mouse = Mouse.create(render.canvas),
                mouseConstraint = MouseConstraint.create(engine, {
                    mouse: mouse,
                    constraint: {
                        stiffness: 0.2,
                        render: {
                            visible: false
                        }
                    }
                });

            Composite.add(world, mouseConstraint);

            // manter o rato sincronizado com a renderização
            render.mouse = mouse;

            // Adicionar event listener para a tecla DEL
            document.addEventListener('keydown', function (event) {
                if (event.key === 'Delete') {
                    // Encontrar o primeiro corpo não estático
                    var bodies = Composite.allBodies(world);
                    for (var i = 0; i < bodies.length; i++) {
                        var body = bodies[i];
                        if (!body.isStatic) {
                            // Log object removal if debug mode is enabled
                            if (debugCheckbox.checked) {
                                console.log('Object Removed (DEL key):', {
                                    id: body.id,
                                    type: body.circleRadius ? 'Circle' :
                                        body.vertices ? 'Polygon' : 'Rectangle',
                                    position: { x: body.position.x, y: body.position.y }
                                });
                            }
                            // Remove o corpo do mundo
                            Composite.remove(world, body);
                            break; // Remove apenas o primeiro objeto encontrado
                        }
                    }
                }
            });

            // Adicionar um event listener de clique com o botão direito do rato à tela para remover corpos
            render.canvas.addEventListener('mousedown', function (event) {
                if (debugCheckbox.checked) {
                    console.log('mousedown', {
                        x: event.clientX,
                        y: event.clientY,
                        button: event.button
                    });
                }
                if (event.button === 2) { // Botão direito
                    // Desabilitar temporariamente o MouseConstraint
                    mouseConstraint.enabled = false;

                    var mousePosition = Mouse.create(render.canvas).position;

                    // Use Matter.Query.point para encontrar corpos que contenham o ponto do mouse
                    var bodies = Query.point(world.bodies, {
                        x: event.clientX,
                        y: event.clientY
                    });

                    if (debugCheckbox.checked) {
                        console.log('world.bodies', world.bodies)
                        console.log(`mousedown: ${event.clientX}, ${event.clientY} bodies id: ${bodies.map(body => body.id)}`, bodies);
                    }

                    // Itere sobre os corpos encontrados e remova-os
                    for (var i = 0; i < bodies.length; i++) {
                        var body = bodies[i];
                        if (!body.isStatic) { // Verifique se o corpo não é estático antes de removê-lo
                            // Log object removal if debug mode is enabled
                            if (debugCheckbox.checked) {
                                console.log('Object Removed:', {
                                    id: body.id,
                                    type: body.circleRadius ? 'Circle' :
                                        body.vertices ? 'Polygon' : 'Rectangle',
                                    position: { x: body.position.x, y: body.position.y }
                                });
                            }
                            Composite.remove(world, body);
                        }
                    }

                    // Reabilitar o MouseConstraint após um pequeno delay
                    setTimeout(() => {
                        mouseConstraint.enabled = true;
                    }, 100);
                }
            }, true);

            // ajustar o viewport de renderização à cena
            Render.lookAt(render, {
                min: { x: 0, y: 0 },
                max: { x: window.innerWidth, y: window.innerHeight }
            });

            // wrapping usando o plugin matter-wrap (integrado diretamente para simplificar)
            var allBodies = Composite.allBodies(world);
            for (var i = 0; i < allBodies.length; i += 1) {
                allBodies[i].plugin = {};
                allBodies[i].plugin.wrap = {
                    min: { x: -100, y: 0 },
                    max: { x: window.innerWidth + 100, y: window.innerHeight }
                };
            }

            // Função de wrapping personalizada
            function wrap(body, bounds) {
                if (body.position.x < bounds.min.x) {
                    Matter.Body.setPosition(body, { x: bounds.max.x - (bounds.min.x - body.position.x), y: body.position.y });
                } else if (body.position.x > bounds.max.x) {
                    Matter.Body.setPosition(body, { x: bounds.min.x + (body.position.x - bounds.max.x), y: body.position.y });
                }

                if (body.position.y < bounds.min.y) {
                    Matter.Body.setPosition(body, { x: body.position.x, y: bounds.max.y - (bounds.min.y - body.position.y) });
                } else if (body.position.y > bounds.max.y) {
                    Matter.Body.setPosition(body, { x: body.position.x, y: bounds.min.y + (body.position.y - bounds.max.y) });
                }
            };

            // Antes da atualização do motor, aplicar o wrap a todos os corpos
            Matter.Events.on(engine, 'beforeUpdate', function () {
                var bounds = render.bounds;
                for (var i = 0; i < allBodies.length; i++) {
                    wrap(allBodies[i], bounds);
                }
            });

            // Adicionar um event listener de mousemove à tela para aplicar repulsão
            render.canvas.addEventListener('mousemove', function (event) {
                var mousePosition = Mouse.create(render.canvas).position;
                var repulsionDistance = 150;  // Ajuste isso para controlar o alcance da repulsão
                var repulsionStrength = 0.05; // Ajuste isso para controlar a força da repulsão

                for (var i = 0; i < allBodies.length; i++) {
                    var body = allBodies[i];
                    var distance = Vector.magnitude(Vector.sub(body.position, mousePosition));

                    if (distance < repulsionDistance) {
                        var direction = Vector.normalise(Vector.sub(body.position, mousePosition));
                        var force = Vector.mult(direction, repulsionStrength);
                        Matter.Body.applyForce(body, body.position, force);
                    }
                }
            });

            // Função para criar um novo corpo aleatório (círculo, polígono ou retângulo)
            function createRandomBody(x, y) {
                var type = Math.random();
                var body;

                if (type < 0.33) { // Círculo
                    body = Bodies.circle(x, y, Common.random(10, 40), {
                        restitution: 0.9,
                        friction: 0.1,
                        render: {
                            fillStyle: Common.choose(['#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C']),
                            strokeStyle: '#B71C1C',
                            lineWidth: 1
                        }
                    });
                } else if (type < 0.66) { // Polígono
                    var sides = Math.floor(Common.random(3, 8));
                    body = Bodies.polygon(x, y, sides, Common.random(20, 50), {
                        restitution: 0.9,
                        friction: 0.1,
                        render: {
                            fillStyle: Common.choose(['#4CAF50', '#8BC34A', '#66BB6A', '#43A047', '#388E3C']),
                            strokeStyle: '#2E7D32',
                            lineWidth: 2
                        }
                    });
                } else { // Retângulo
                    var width = Common.random(30, 80);
                    var height = Common.random(30, 80);
                    body = Bodies.rectangle(x, y, width, height, {
                        restitution: 0.9,
                        friction: 0.1,
                        render: {
                            fillStyle: Common.choose(['#2196F3', '#64B5F6', '#42A5F5', '#1E88E5', '#1565C0']),
                            strokeStyle: '#0D47A1',
                            lineWidth: 2
                        }
                    });
                }

                // Log object creation if debug mode is enabled
                if (debugCheckbox.checked) {
                    console.log('Object Created:', {
                        id: body.id,
                        type: type < 0.33 ? 'Circle' : type < 0.66 ? 'Polygon' : 'Rectangle',
                        position: { x: body.position.x, y: body.position.y },
                        size: type < 0.33 ? { radius: body.circleRadius } :
                            type < 0.66 ? { sides: body.vertices.length, radius: body.radius } :
                                { width: body.width, height: body.height }
                    });
                }

                return body;
            }

            // Adicionar um event listener de clique à tela para criar um novo objeto aleatório
            render.canvas.addEventListener('click', function (event) {
                var mousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };

                // Encontrar o corpo clicado
                var bodies = Query.point(world.bodies, {
                    x: event.clientX,
                    y: event.clientY
                });

                if (bodies.length > 0) {
                    // Pegar o primeiro corpo não estático encontrado
                    var clickedBody = bodies.find(body => !body.isStatic);

                    if (clickedBody) {
                        // Calcular a direção do centro do corpo até o ponto de clique
                        var direction = Vector.sub(clickedBody.position, mousePosition);
                        // Normalizar a direção
                        direction = Vector.normalise(direction);

                        // Calcular a distância do centro até o ponto de clique
                        var distance = Vector.magnitude(Vector.sub(clickedBody.position, mousePosition));

                        // Calcular a força baseada na distância (quanto mais longe do centro, maior a força)
                        var force = Vector.mult(direction, distance * 0.01); // Ajuste o multiplicador conforme necessário

                        // Aplicar a força no corpo
                        Matter.Body.applyForce(clickedBody, clickedBody.position, force);

                        if (debugCheckbox.checked) {
                            console.log('Body Repelled:', {
                                id: clickedBody.id,
                                type: clickedBody.circleRadius ? 'Circle' :
                                    clickedBody.vertices ? 'Polygon' : 'Rectangle',
                                position: { x: clickedBody.position.x, y: clickedBody.position.y },
                                force: force,
                                distance: distance
                            });
                        }
                    }
                } else {
                    // Se não clicou em nenhum corpo, criar um novo
                    var randomBody = createRandomBody(event.clientX, event.clientY);
                    Composite.add(world, randomBody);
                }
            });

            // contexto para MatterTools.Demo
            return {
                engine: engine,
                runner: runner,
                render: render,
                canvas: render.canvas,
                stop: function () {
                    Matter.Render.stop(render);
                    Matter.Runner.stop(runner);
                }
            };
        };

        window.onload = function () {
            Example.ballPool();
        };
    </script>
</head>

<body>
</body>

</html>